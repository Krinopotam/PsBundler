# Импорты модулей в PowerShell: когда хочется как в JavaScript #

## Введение ##

В рамках рабочей задачи мне пришлось разрабатывать несколько достаточно сложных приложений на PowerShell. По мере роста сложности стало очевидно, что код необходимо разделять на логически независимые части, и это естественным образом привело к необходимости модульной структуры.

Но ввиду работы в закрытом контуре и связанных с этим сложностей переноса и развертывания многофайловых проектов на целевых машинах, одним из требований стала возможность сборки модульного приложения в однофайловый скрипт (бандл).

До этого опыта я практически не работал с PowerShell и был больше знаком с подходами к организации кода, принятыми в других языках, в частности в JavaScript. В процессе работы пришлось изучить существующие в PowerShell механизмы подключения кода из других файлов, их типичные сценарии использования, а также связанные с ними ограничения и компромиссы.

В данной статье я хочу поделиться своими наблюдениями и описать подход, который оказался наиболее подходящим для моей задачи.

>Всё изложенное ниже основано на моём личном опыте, не претендует на абсолютную истину и относится к PowerShell версии 5.1. Материал может содержать трактовки, вызванные моей собственной некомпетентностью в PowerShell и ориентирован на разработчиков, привыкших к более классическим языкам программирования

Для начала имеет смысл рассмотреть, какие способы разделения кода на файлы и методы их подключения вообще существуют в PowerShell.

## Механизмы выполнения и подключения внешнего кода ##

Мне известно 4 основных способа:

1. `Dot`-sourcing — выполнение кода из файла в текущей области видимости.
2. `Ampersand`-call (`&`-вызов) — выполнение в дочерней области видимости.
3. Команда `Import-Module` — динамическая загрузка модуля в сессию.
4. Директива `Using module` — статическая декларация зависимости (на этапе парсинга)

*За рамками данного обзора остаются механизмы разрешения зависимостей через свойство `RequiredModules` в манифесте модуля (`.psd1`), а также иные способы динамической загрузки и выполнения кода (например, через `Invoke-Expression`), поскольку они не соответствуют целям статьи и рассматриваемой модели организации приложения.*

Рассмотрим каждый из вариантов.

### 1. `Dot`-sourcing ###

Как следует из названия, синтаксис `Dot`-sourcing начинается с точки `"."`, и дальше указывается путь до подключаемого файла `ps1` или `psm1`.

Относительные пути, указанные в `Dot`-sourcing, рассчитываются из текущего рабочего каталога (current location) сессии PowerShell, что не всегда удобно. Поэтому, общепринятой практикой является использование в качестве префикса пути встроенной переменной `$PSScriptRoot`, которая хранит в себе путь до директории текущего выполняемого скрипта. Например, `"$PSScriptRoot\module.ps1"` вернет путь до файла `module.ps1` из той-же директории, что и вызывающий скрипт.

Пример использования:

```powershell
# module.ps1

function Start-ModuleFunction {...}
```

```powershell
# run.ps1

. "$PSScriptRoot\module.ps1"

Start-ModuleFunction
```

Во время выполнения скрипта `run.ps1` PowerShell загрузит и выполнит скрипт `module.ps1` в текущей области видимости (**scope**), из-за чего все определения (функции, переменные, алиасы) становятся частью **scope** вызывающего скрипта. Это похоже на то, как если бы PowerShell просто заменил строку `. ".\module.ps1"` в файле `run.ps1` на содержимое файла `module.ps1`.

Для небольших приложений данный метод вполне уместен, но в более сложных приложениях отсутствие изоляции областей видимости может привести к трудноотслеживаемым багам и необходимости вручную обеспечивать уникальность наименований функций и переменных во всех скриптах.

**Плюсы**: простота  
**Минусы**: общая область видимости, отсутствие изоляции кода

### 2. `Ampersand`-call ###

По сути очень похоже `Dot`-sourcing.

```powershell
# run.ps1

& "$PSScriptRoot\module.ps1"

# other code...
```

Отличие от `Dot`-sourcing заключается в том, что при использовании `&`-вызова PowerShell выполнит файл `module.ps1` как отдельную команду в дочерней области видимости скрипта `run.ps1`, а не в текущей, как при `Dot`-sourcing. По эффекту это похоже на выполнение кода внутри отдельного скрипт-блока (`{...}`).

Таким образом, области видимости у кода из `module.ps1` и кода в `run.ps1` будут разными. Так как, области видимости в PowerShell иерархические, то есть дочерний скрипт-блок видит объекты своего родителя, но родитель не видит объекты своего дочернего скрипт-блока, то и при `&`-вызове скрипт из `module.ps1` будет видеть функции из корневого скрипта `run.ps1`, но не наоборот — из скрипта `run.ps1` нельзя будет напрямую обратиться к объектам скрипта `module.ps1`. Таким образом, с одной стороны обеспечивается частичная (однонаправленная) изоляция, с другой — неудобный доступ к членам подключенного скрипта, что не очень хорошо подходит для задачи разделения кода на модули. Тем не менее, для частных задач такой подход тоже может быть применим.

**Плюсы**: простота импорта, разные области видимости  
**Минусы**: нет полной изоляции модуля, неудобно обращаться к импортированным объектам

### 3. Команда `Import-Module` ###

Создание модулей это основной рекомендуемый подход по разделению кода и для их подключения предусмотрена команда `Import-Module`:

- модуль загружается в отдельную область видимости (**module-scope**), что помогает изолировать внутренние переменные/вспомогательные функции.
- можно экспортировать только нужные функции (через `Export-ModuleMember` или настройки в манифесте).
- модули удобно переиспользовать и распространять (структура папок, версия, зависимости, автозагрузка)

В PowerShell для модулей принято использовать отдельное расширение `.psm1` — по содержимому это тот же PowerShell-скрипт, что и `.ps1`, но предназначенный именно для подключения как модуль. При необходимости модуль может дополняться необязательным манифестом с расширением `.psd1`, где в виде обычного PowerShell объекта описываются версия, экспортируемые команды и зависимости и другие реквизиты модуля. Также через команду `Import-Module` в качестве модуля можно подключить и обычный `.ps1` скрипт (и иногда это даже лучше, но об этом позже).

Ниже пример подключения простого модуля:

```powershell
# module.psm1

function Start-PublicFunction {...}
```

```powershell
# main.ps1

Import-Module ".\module.psm1"

Start-PublicFunction
```

В данном примере все функции из `module.psm1` будут доступны в `main.ps1`, но области видимости у них будут разными — функции модуля будут выполняться в **module-scope**:

- функции модуля **видят** другие функции и переменные своего модуля, даже если они не экспортированы.
- функции модуля **не видят** функции и переменные, определенные вне модуля (например, в `main`), даже уровня `script` (но видят `global`).

Чтобы указать, что именно должно быть экспортировано из модуля, можно (и часто нужно) использовать команду `Export-ModuleMember`. Например:

```powershell
# module.psm1

function Start-PublicFunction {...}

function Start-PrivateFunction {...}

Export-ModuleMember -Function Start-PublicFunction
```

В данном случае, экспортирована будет только функция `Start-PublicFunction`. Импортирующий скрипт будет видеть эту функцию, но не будет видеть функцию `Start-PrivateFunction`. При этом сама `Start-PublicFunction` будет видеть функцию `Start-PrivateFunction`.

По умолчанию, в модуле без манифеста и без вызова команды `Export-ModuleMember` экспортируются все функции, но не переменные или алиасы. Если в модуле команда `Export-ModuleMember` вызывается, то экспортируется только то, что указано в параметрах этой команды.

Также, в самой команде `Import-Module` можно указать, что импортировать, например:

```powershell
# main.ps1

Import-Module ".\module.psm1" -Function Start-PublicFunction
```

Ну а дальше, немного нюансов.

Первый нюанс заключается в том, как работает вложенный импорт (когда модуль импортирует другой модуль).

Проблема вложенного импорта проявляется, когда модуль не ограничивает экспортируемые команды: если, например, `module1` импортирует `module2`, то при импорте `module1` в вызывающий скрипт могут “протечь” не только его собственные функции, но и функции из `module2`.

Microsoft рекомендует описывать зависимости модулей через параметр `RequiredModules` в манифесте (`.psd1`), а не полагаться на их загрузку из кода модуля (например, через вложенные вызовы `Import-Module`). Такой подход обеспечивает детерминированную загрузку зависимостей и более предсказуемое поведение экспорта, независимо от порядка импорта модулей.

На мой взгляд, использование манифеста и `RequiredModules` в первую очередь оправдано для “библиотечных” модулей, которые планируется распространять или переиспользовать в разных проектах. Если же модуль используется локально — как простой файл для подключения набора функций внутри одного проекта, — создавать отдельный манифест для каждого `.psm1` неудобно. В таких случаях достаточно явно управлять экспортом через `Export-ModuleMember`, чтобы наружу попадали только нужные функции.

Второй нюанс заключается в том, как ведет себя PowerShell при импорте двух функций с одинаковыми именами. Предположим, у нас есть 2 модуля `module1.psm1` и `module2.psm1`, в которых есть функции `Use-Test`:

```powershell
# module1.psm1

function Use-Test {
    Write-Host "I am Use-Test from module1"
}

# module2.psm1

function Use-Test {
    Write-Host "I am Use-Test from module2"
}

```

Если мы последовательно импортируем оба этих модуля и вызовем функцию `Use-Test`, то сработает функция из второго модуля, который был импортирован последним.

```powershell
# main.ps1

Import-Module "$PSScriptRoot\module1.psm1"
Import-Module "$PSScriptRoot\module2.psm1"

Use-Test
```

```output
I am Use-Test from module2
```

Получается, что функция из `module2.psm1` "перезатерла" одноименную функцию из `module1.psm1`.

Но это не совсем так. Если мы выполним команду `Get-Command Use-Test -All`, то мы увидим, что в нашей сессии на самом деле 2 версии функции `Use-Test`, одна из `module1`, вторая из `module2`.

```output
>Get-Command Use-test -All

CommandType     Name           Version    Source
-----------     ----           -------    ------
Function        Use-Test       0.0        module2
Function        Use-Test       0.0        module1
```

И к каждой из версий мы можем обратиться по квалифицированному имени, указав имя модуля:

```powershell
module1\Use-Test
module2\Use-Test
```

```output
I am Use-Test from module1
I am Use-Test from module2
```

И это может нас натолкнуть на мысль: а ведь неплохо было бы иметь возможность делать полностью изолированные импорты, то есть импортировать модули так, чтобы объекты из модулей не попадали напрямую в области видимости вызывающего скрипта, а чтобы обращаться к ним можно было бы только через квалифицированное имя. И такое решение на самом деле есть:

```powershell
# main.ps1

& {Import-Module "$PSScriptRoot\module1.psm1"}
& {Import-Module "$PSScriptRoot\module2.psm1"}

module1\Use-Test # вызов функции из module1
module2\Use-Test # вызов функции из module2
Use-Test         # ошибка
```

Как это работает? Вызов `Import-Module` помещает все экспортированные функции модуля в **scope** вызывающего скрипта. Мы избавляемся от этого поведения, вызывая импорт внутри временного скрипт-блока (`{...}`). Таким образом, все экспортированные функции попадают в **scope** временного скрипт-блока, а не засоряют **scope** вызывающего скрипта, но сам модуль остается загруженным в сессию и доступ к его членам возможен через квалифицированное имя.

При данном подходе нам не нужно заботиться об уникальности наименований функций ни в модулях, ни в вызывающем скрипте.

К сожалению, есть и ложка дегтя. Сохранить такую же функциональность в однофайловом бандле сложно (подробнее в разделе про создание бандла). А если бандл не нужен, то в остальном вполне рабочее решение.

**Плюсы**: изоляция областей видимости, гибкость, контроль версий, честная модульность "из коробки".  
**Минусы**: сложнее, чем `Dot`-нотация, больше кода.

### 4. Директива `using module` ###

Согласно официальной документации, директива `using module` предназначена только для импорта типов (классов, перечислений). Но, на практике (по крайней мере в PowerShell 5.1), она приводит к загрузке модуля целиком, и функции становятся доступны аналогично `Import-Module`.

Главное отличие от `Import-Module` заключается в том, что `using module` это директива, а не команда, и выполняется она на этапе парсинга скрипта, а не исполнения. А так как в PowerShell проверка типов, используемых в классах, осуществляется на этапе парсинга, то директива `using module` для импорта модулей-классов является практически безальтернативной.

Также, директива `using module` имеет ряд важных нюансов:

- Директива `using` должна быть в самом начале скрипта (выше всего, что не является комментарием).
- Несмотря на то, что директива обрабатывается на этапе парсинга вызывающего скрипта, она приводит к загрузке, парсингу и выполнению импортируемого модуля.  Другими словами, вызывающий скрипт будет находиться еще в режиме парсинга, а вызываемый уже в режиме исполнения. Это позволяет в импортируемом скрипте использовать команды, например `Export-ModuleMember`, которые работают на этапе выполнения, а не парсинга.
- В момент парсинга служебные переменные, типа `$PSScriptRoot` еще не созданы и их нельзя использовать для определения пути импортируемого модуля.
- В отличие от команды `Import-Module`, в которой относительный путь рассчитывается от текущего рабочего каталога сессии PowerShell, путь в директиве `using module` рассчитывается от директории, в которой располагается вызывающий скрипт. Другими словами, если в случае с `Import-Module` для получения директории текущего файла нам приходится использовать переменную `$PSScriptRoot`, например, `$PSScriptRoot\module1.psm1`, то в случае с `using module` аналогичный результат достигается сразу через `.\module1.psm1`.

**Плюсы**: простота импорта, высокая изоляция, безальтернативность при импорте типов (классов и перечислений).  
**Минусы**: меньше гибкости, чем у `Import-Module`, директива должна быть размещена только вначале скрипта, дополнительные сложности, связанные с тем, что импорт осуществляется на этапе парсинга, а не выполнения.

## Принятые подходы к организации модульного кода в PowerShell ##

В официальной документации PowerShell модули рассматриваются преимущественно как единицы распространения и повторного использования функциональности. Вопросы внутренней композиции приложений и файлово-ориентированной модульности напрямую практически не рассматриваются, поэтому соответствующие архитектурные решения остаются на усмотрение разработчика и зависят от конкретного сценария использования.

### Классический PowerShell подход к организации кода ###

Если попытаться поискать лучшие практики по созданию модулей в PowerShell, то практически всегда будет встречаться один и тот же паттерн в той или иной реализации. Обычно модуль оформляют как папку с именем модуля, внутри которой лежит одноименный файл модуля `.psm1` (и при необходимости манифест `.psd1`), а каждую функцию выносят в отдельный `.ps1` файл.

Далее модуль разбивается на две части — публичную и внутреннюю, обычно через структуру папок `Public` и `Private`:

- в `Public` складываются функции, которые составляют внешний API модуля;
- в `Private` — вспомогательные функции, которые используются внутри, но не должны быть доступны пользователю модуля.

Ниже пример организации модуля:

```output
MyModule/
  MyModule.psd1
  MyModule.psm1
  Public/
    Get-Thing.ps1
  Private/
    Invoke-Internal.ps1
```

```powershell
# MyModule.psm1

# Load private and public functions
$Public  = Join-Path $PSScriptRoot 'Public'
$Private = Join-Path $PSScriptRoot 'Private'

Get-ChildItem $Private -Filter *.ps1 -ErrorAction SilentlyContinue | ForEach-Object { . $_.FullName }
Get-ChildItem $Public  -Filter *.ps1 -ErrorAction SilentlyContinue | ForEach-Object { . $_.FullName }


# Export only public API
Export-ModuleMember -Function (Get-ChildItem $Public -Filter *.ps1 -ErrorAction SilentlyContinue | Select-Object -ExpandProperty BaseName)
```

В самом файле модуля `.psm1` содержимое файлов с функциями обычно подгружается при помощи `dot`-sourcing, а затем экспорт ограничивается только функциями из `Public` (чаще всего через `Export-ModuleMember`). Такой подход удобен тем, что явно разделяет API и внутреннюю реализацию и снижает риск “протекания” лишних функций наружу.

**Плюсы**:

- Автоматическое подключение функций: достаточно положить файл в нужную папку и модуль подхватит его при импорте.
- Четкое разделение API и внутренней реализации: все, что в `Public`, автоматически считается публичным контрактом, а `Private` остается внутренним.
- Предсказуемый экспорт: проще гарантировать, что наружу попадет только нужное.
- Меньше конфликтов при работе в команде: изменения чаще затрагивают разные файлы, меньше merge-конфликтов.
- Проще покрывать тестами: функции изолированы в отдельных файлах.
- Не засоряет область модулей сессии множеством внутренних модулей: снаружи всегда импортируется один модуль. Это упрощает управление окружением (меньше “видимых” модулей, меньше шума в `Get-Module`) и снижает риск конфликтов из-за случайного импорта лишних модулей в сессии.
- По сравнению с подходом, где каждый компонент подключается как отдельный модуль, `dot`-sourcing обычно проще и имеет меньшие накладные расходы.

**Минусы**:

- Общая область видимости модуля: `dot`-sourcing загружает все функции в один **module scope**, что повышает риск неявных зависимостей и конфликтов имен.
- Накладные расходы при импорте: выделение отдельного файла на каждую функцию увеличивает количество обращений к файловой системе и время парсинга, что заметно в больших модулях (особенно на холодном старте).
- Много мелких файлов: структура становится громоздкой если функций много.
- Не всегда прозрачные зависимости: функции могут неявно зависеть друг от друга, без дисциплины быстро появляется “паутина” внутренних вызовов.
- Деление только на `Public`/`Private` плохо масштабируется: в больших кодовых базах чаще требуется группировка по предметным областям (domain-oriented structure), а не только по уровню доступа.
- Слабо подходит для универсального бандлинга (сборки в один файл): подключение файлов делается динамически (через циклы, условия), поэтому “универсальный” бандлер, который просто анализирует статические Import-Module/using, не сможет надежно определить зависимости. Придется писать либо собственный скрипт сборки, либо ограничивать логику загрузки до простого и предсказуемого шаблона и использовать решения именно для такого шаблона.

Классический паттерн `Public`/`Private` + `dot`-sourcing в первую очередь ориентирован на модули-библиотеки и утилитарные наборы команд. Особенно хорошо он подходит для сценариев, где модуль используется в долгоживущих сессиях (интерактивная работа, администрирование,), и где важны простота ручного подключения/отключения модулей и предсказуемость окружения (один импортируемый модуль вместо набора подмодулей).

При этом такой подход хуже поддаётся сборке в один файл: подключение файлов обычно реализуется динамически, поэтому универсальные инструменты сборки не могут надежно определить зависимости и порядок включения.

В то же время, по мере роста функциональности и усложнения внутренних зависимостей этот подход начинает хуже масштабироваться как основа приложения, и чаще требует перехода на более структурированные паттерны (например, вложенные модули или классы).

### Подход с вложенными модулями ###

В этом варианте манифест также пишется только для корневого модуля, а доменные части оформляются как отдельные внутренние модули (`.psm1`). Корневой модуль при импорте явно импортирует вложенные модули через `Import-Module` и затем экспортирует наружу только то, что нужно.

Пример структуры:

```output
MyModule/
  MyModule.psd1
  MyModule.psm1
  Modules/
    Auth/
      Auth.psm1
    Storage/
      Storage.psm1
    Utils/
      Utils.psm1
```

Пример корневого файла модуля:

```powershell
# MyModule.psm1

$modulesRoot = Join-Path $PSScriptRoot 'Modules'

Import-Module (Join-Path $modulesRoot 'Auth\Auth.psm1') -Scope Local
Import-Module (Join-Path $modulesRoot 'Storage\Storage.psm1') -Scope Local
Import-Module (Join-Path $modulesRoot 'Utils\Utils.psm1') -Scope Local

# Export public API
Export-ModuleMember -Function @(
  'Invoke-App',
  'Get-Token',
  'Get-Thing',
  'Set-Thing'
)
```

Вложенные модули сами определяют свои экспортируемые члены (через `Export-ModuleMember` в каждом .psm1), а корневой модуль решает, что и как “поднимать” наружу.

**Плюсы**:

- Явная композиция и структура: модуль становится набором подсистем (`Auth`, `Storage`, `Utils`), а не просто `Public`/`Private`.
- Изоляция и дисциплина: каждый подмодуль — отдельный **module scope**, меньше пересечений имен и случайных зависимостей.
- Удобнее для “приложений”: проще выделять компоненты, границы ответственности и контракт между ними.
- Гибкость экспорта: можно экспортировать наружу либо напрямую из подмодулей, либо “обёртками” из корня, либо комбинировать.
- Хорошо подходит для универсального бандлинга: импорты подмодулей, как правило, статические и явные. Это упрощает анализ зависимостей и позволяет использовать универсальные инструменты, которые собирают модуль в один файл или создают минимальный артефакт.

**Минусы**:

- Больше кода: нужно поддерживать структуру импорта и экспортов на нескольких уровнях.
- Производительность импорта: накладные расходы на импорт модулей могут быть дороже, чем `dot`-sourcing (но не всегда, о чем ниже).

Подход хорошо подходит, когда проект — уже не просто библиотека, а модуль как приложение или “платформа” с доменами. Он вводит естественные границы и снижает неявные зависимости ценой чуть большей сложности.

Отдельно стоит сказать про производительность.

В чистом виде, `dot`-sourcing имеет меньше накладных расходов, чем импорт модуля. При импорте модуля `.psm1` PowerShell также осуществляет поиск и его манифеста `psd1` (а при его наличии еще и парсинг). Также для каждого модуля создается отдельный **module scope**.

Я провел некоторые замеры для двух тестовых наборов. В первом случае в главном модуле подключались через `dot`-sourcing 100 скриптов `.ps1` (в каждом по 5 функций) и выполнялись выборочно 10 функций из них, во втором — импортировались  100 аналогичных модулей `.psm1` через `Import-Module` и также выполнялись 10 функций. Содержимое функций одинаковое, в каждом файле по 5 функций. Результаты получились следующими:

| Метод | Выполнение в ms | CPU | ОЗУ |
| --- | --- | --- | --- |
| `Dot`-sourcing | 286 | 472 | 69 |
| `Import-Module` | 332 | 497 | 84 |

Получилось, что `Dot`-sourcing в части производительности и потребления памяти эффективнее, чем `Import-Module` в пределах 10-20 процентов, хотя речь идет о десятках миллисекунд на 100 файлов.

Но `Import-Module` можно еще ускорить. Если вместо расширений импортируемых модулей `.psm1` использовать `.ps1`, то PowerShell их будет загружать как обычные модули, но не будет осуществлять поиск манифестов. И здесь уже замеры показали, что `Dot`-sourcing быстрее всего на 3%, что уже ближе к статистической погрешности. Для внутренних модулей, для которых не важен контроль версий и автозагрузка это вполне рабочее решение.

При этом, в тестируемом сценарии я использовал файлы, в каждом из которых по 5 функций. Если же использовать классический паттерн организации модуля в PowerShell, когда для каждой функции выделяется отдельный файл, то скорее всего подход с вложенными модулями будет эффективнее, чем классический подход с `dot`-sourcing.

### Класс-ориентированный подход (ООП) ###

Если проект ближе к приложению (с сущностями, состояниями, поведением, сервисами и зависимостями), логичным шагом становится переход к классам. В PowerShell это означает: модули оформляются как классы, а подключение выполняется через директиву `using module`.

Пример структуры:

```output
MyModule/
  MyModule.psd1
  MyModule.psm1
  Classes/
    Client.psm1
    Config.psm1
    Storage.psm1
```

Пример корневого модуля:

```powershell
# MyModule.psm1

using module .\Classes\Config.psm1
using module .\Classes\Client.psm1

$config = [MyModuleConfig]::new("prod")
$client = [MyModuleClient]::new($config)
$client.Connect()
```

Пример класса:

```powershell
# Client.psm1

using module .\Config.psm1

Class MyModuleClient {
    # class property
    [MyModuleConfig]$config

    # constructor
    MyModuleClient($config){
        $this.config = $config
    }

    # class method
    [void]Connect() {
        ...
    }
}

```

**Плюсы**:

- Лучше подходит для приложения: классы естественно отражают модель предметной области, состояние и взаимодействие компонентов, строже контроль типов.
- Четкие границы и зависимости: конструкторы, свойства, интерфейсы, композиция — всё делает связи явнее, чем при “общем scope”.
- Меньше риска “протекания” функций: API становится типизированным, а детали реализации остаются внутри классов.
- Удобнее расширять архитектуру: когда появляются подсистемы, сервисы, клиентские объекты, провайдеры и т.д.
- Меньше “магии” PowerShell и больше предсказуемости: при переходе на классы существенная часть типичного для PowerShell [неоднозначного поведения](https://habr.com/ru/articles/976278/) (неявные преобразования, особенности пайплайна и т.д.) уходит на второй план. Код начинает вести себя ближе к классическим ООП-языкам.
- Также, как и шаблон со вложенными модулями, хорошо (но с некоторыми нюансами) подходит для универсального бандлинга: `using module` — это статическая директива, которая хорошо читается анализаторами зависимостей.

**Минусы**:

- Порог входа выше и не каждому разработчику подходит ООП.
- Сложнее тестирование: класс-ориентированный код часто требует другой стратегии тестов и моков.
- Не всегда оправдано: если модуль остаётся “набором команд”, классы могут быть избыточны.
- Ограничения PowerShell-классов: по сравнению с C# это менее гибкий инструмент, и иногда приходится подстраиваться под особенности языка.

Этот подход особенно хорош, когда модуль — это приложение, а не библиотека: он улучшает читаемость архитектуры, делает зависимости явными и позволяет строить устойчивую внутреннюю композицию. Для небольших утилитных модулей часто избыточен.

Но при работе с классами есть ряд нюансов, которые обязательно нужно учитывать.

- контроль типов, используемых в классе осуществляется на этапе парсинга скрипта.
- циклический импорт не допускается: класс `A` не может ссылаться на тип класса `B` если класс `B` ссылается на тип класса `A`.

Контроль типов на этапе парсинга может привести к неочевидной проблеме. Например, в своем классе мы хотим использовать сборку `System.Windows.Forms` и по этому добавляем ее тип через команду `Add-Type -AssemblyName System.Windows.Forms`. Но`Add-Type` это команда, выполняемая на этапе выполнения кода, а как уже было сказано выше, проверка типов класса ведется на этапе парсинга класса.  Плюс мы не можем поместить `Add-Type` в коде выше, чем  `using module`. А значит, класс не будет видеть тип `System.Windows.Forms` (мы не сможем его использовать, например для создания экземпляра `[System.Windows.Forms.Form]::New()`), и будет ошибка.

По идее нам бы могла помочь директива `using assembly`, которая как раз и является аналогом команды `Add-Type`, только работающая на этапе парсинга, но к сожалению, и это не сработает (обсуждение проблемы [здесь](https://stackoverflow.com/questions/42837447/powershell-unable-to-find-type-when-using-ps-5-classes/42839957#42839957)). Больше похоже на недоработку в PowerShell, которую до сих пор не исправили.

Какие есть решения:

- создавать объекты через `New-Object System.Windows.Forms.Form`, но при этом мы теряем строгую типизацию, автодополнение в IDE, а также немного производительность.
- если же необходимо использовать динамически создаваемые типы на основе встраиваемого C# кода, то можно создать отдельный модуль с необходимыми сборками, а уже этот модуль импортировать через `using module`. Например:

```powershell
#typesModule.psm1

Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName System.Drawing

Add-Type @"
using System;
using System.Runtime.InteropServices;
public class Win32 {
    [DllImport("user32.dll", CharSet = CharSet.Auto)]
    public static extern IntPtr SendMessage(IntPtr hWnd, int msg, int wParam, IntPtr lParam);
}
"@

#MyClass.ps1
using module .\typesModule.psm1

Class MyClass {
    [void]CreateForm () {
        $form = [System.Windows.Forms.Form]::New() # используем статическую сборку
        [void][Win32]::SendMessage(...) # используем динамическую сборку
    }
}

```

В этом случае загрузка сборок `Forms` и `Drawing` и класса `Win32` будет выполнена до проверки типов в `MyClass.ps1` и их можно будет использовать в классе.

Но есть и минус — реализовать такое-же поведение в бандле без некоторых "хаков" не получится. Придется выкручиваться, о чем ниже.

## Как создать однофайловый бандл из модульного проекта ##

В рамках своих проектов, я пришел к выводу, что мне побольше подходят шаблоны организации кода со вложенными импортами или классовыми модулями. И там и там используются статические импорты, поэтому было принято решение разработать универсальный бандлер, который бы мог собирать проекты в одиночные файлы.


Требование “собрать всё в один файл” в PowerShell часто вступает в конфликт с тем, как устроены модули и загрузка кода. В JavaScript это уже давно решено стандартными инструментами (webpack/rollup/esbuild), а в PowerShell универсального бандлера нет: обычно всё заканчивается либо ручной “склейкой”, либо кастомными скриптами сборки под конкретный проект.

В моём случае хотелось сохранить модульную структуру разработки, но при этом иметь возможность выпускать единый артефакт для развертывания в закрытом контуре. Для себя я принял, что мне больше подходят шаблоны организации кода со статическими импортами и изоляцией областей видимости (вложенные модули или классовые модули). В итоге я написал [собственный бандлер](https://github.com/Krinopotam/PsBundler) для PowerShell 5.1, который собирает модульные проекты в один файл.

Если захотите реализовать свой — в этом разделе постараюсь пересказать концепцию, которую я использовал.

### Почему нельзя просто “склеить файлы” ###

Самая распространённая попытка — взять все .ps1/.psm1 и просто конкатенировать их в один файл. В простых проектах это иногда работает, но с ростом сложности ломается по нескольким причинам:

1. **PowerShell есть синтаксис, который обязан находиться в начале файла**.
Например, директивы `using`, `[CmdletBinding()] param` (для корневого скрипт-блока)  должны располагаться выше любого кода, кроме комментариев и пустых строк. Если просто склеить несколько файлов, такие директивы неизбежно окажутся “в середине” итогового скрипта, и PowerShell выдаст ошибку парсинга ещё до выполнения.

2. **В PowerShell есть импорты, работающие на разных этапах**.
`Import-Module` выполняется в рантайме, а `using module` обрабатывается на этапе парсинга. “Склейка” уничтожает исходный порядок и контекст, и в какой-то момент начинает зависеть от случайности.

3. **Путь к файлам перестаёт существовать**.
`Import-Module "$PSScriptRoot\module.psm1"` и `. "$PSScriptRoot\file.ps1"` в бандле превращаются в попытку загрузить несуществующие файлы.

4. **Меняются области видимости и возникают конфликты имен**.
В исходном проекте модуль живет в **module scope**, а в склеенном файле всё оказывается в одном **script scope**. Это приводит к утечкам переменных, коллизиям имен и “магическим” зависимостям.

5. **Классы — отдельная боль**.
Для классов нужен корректный импорт типов на этапе парсинга. Если типы не загружены заранее — код падает ещё до выполнения, и “поправить в рантайме” уже нельзя.

**Отсюда ключевой вывод**: бандлер должен не просто “склеивать текст”, а восстанавливать семантику импорта — кто что импортирует, в каком **scope** и на каком этапе.

### Что должен уметь универсальный бандлер ###

Если обобщить, универсальный бандлер должен решить три задачи:

1. Разрешить зависимости: найти импорты, построить порядок, проверить на циклы.
2. Заменить импорты на эквивалент внутри одного файла.
3. Сохранить поведение: области видимости, экспорт, доступ по ModuleName\Command, совместимость с классами.

Дальше я сначала опишу общую схему, которую использует мой бандлер, а затем пройдусь по каждому механизму импорта и покажу, как он реализуется в бандле.

### Базовые концепции ###

Для проекта создается специальный конфиг файл в формате `json`, в котором указывается entrypoint-файл (по аналогии с WebPack). Бандлер начинает работу с этого корневного файла и рассматривает проект как замкнутый набор исходников. Всё, что находится вне этого набора (стандартные модули, внешние зависимости) — не “встраивается”, а остаётся как есть.

Для начала каждый файл преобразуется в абстрактное синтаксическое дерево (AST), в нем выявляются статические подключения и импорты файлов, их типы и пути. На основе анализа строится граф зависимостей.

Следующим этапом является очистка содержимого импортируемых файлов от комментариев (если есть такая необходимость) и выявление и вынос конструкций, которые обязательно должны быть в самом верху итогового бандла (те же `using` и др.).





Ниже — как это делается для каждого механизма импорта.



Как “эмулировать” импорты внутри одного файла
1) Dot-sourcing (. file.ps1)

Оригинальная семантика:
код из файла выполняется в текущем scope (обычно script scope или module scope).

Что ломается в бандле:
пути больше нет → нечего “dot-sourcing’ить”.

Эмуляция в бандле:
самый прямой вариант — заменить dot-sourcing на вставку текста файла (inline) в месте подключения. Это буквально то, как работает dot-sourcing по смыслу.

Нюанс:
если dot-sourcing используется динамически (циклы, условия, Get-ChildItem), универсальная сборка становится сложнее: бандлер должен либо понимать этот шаблон, либо проект должен соблюдать ограничение “только статические импорты”.

2) Ampersand-call (& file.ps1)

Оригинальная семантика:
файл выполняется как отдельная команда в дочернем scope. Объекты, созданные внутри, не видны родителю (если явно не протекать через global: и т.п.).

Эмуляция в бандле:
оборачивать содержимое подключаемого файла в скрипт-блок и вызывать его:

& {
    # содержимое file.ps1
}


Это сохраняет главное свойство: дочерний scope.

Нюанс:
если файл рассчитывает на $MyInvocation, $PSScriptRoot или относительные пути — бандлеру придется либо подменять эти значения, либо переписывать обращения.

3) Import-Module

С Import-Module всё интереснее, потому что он делает сразу две вещи:

загружает модуль в сессию,

импортирует экспортируемые команды в выбранный scope.

В бандле файлов нет, поэтому “загрузка модуля с диска” невозможна. Но нам всё равно хочется:

отдельный module scope для каждого модуля (изоляция),

возможность вызывать ModuleName\Command,

(в идеале) контролировать, какие команды “попадают” в текущий scope.

Эмуляция в бандле:
создавать модули в памяти через New-Module и затем импортировать их так же, как если бы это был обычный модуль:

New-Module -Name <имя> -ScriptBlock { ... }

Import-Module <объект модуля>

Это даёт настоящий module scope и работает в PowerShell 5.1.

Нюанс №1: экспорт
если модуль использует Export-ModuleMember, то он должен отработать внутри module scope — и именно New-Module это обеспечивает.

Нюанс №2: изолированный импорт
если в проекте использовался трюк “импортировать модуль внутри скрипт-блока, чтобы команды не засоряли scope”, то в бандле это можно воспроизвести тем же способом:

& { Import-Module $ModuleObject }

4) using module

using module — самая проблемная часть любого бандлера.

Оригинальная семантика:
обрабатывается на этапе парсинга, поэтому позволяет использовать типы из модуля в классах и сигнатурах.

Почему это сложно в бандле:
внутри одного файла нельзя “переобъявить” using module, потому что он должен быть в начале файла, и он ожидает реальный файл модуля.

Типовые решения:

(а) Ограничение архитектуры: “в бандле мы не используем using module, всё решаем через функции/модули в рантайме”. Подходит, если классов нет или типизация между файлами не критична.

(б) Выделить слой типов: все классы/enum’ы вынести в специальный блок и поместить его в самое начало итогового файла. Это позволяет сохранить parse-time типы без using module.

(в) Генерация временных файлов: бандлер на лету распаковывает “виртуальные модули” во временную директорию и выполняет настоящий using module по пути. Это самый совместимый способ, но он нарушает идею “полностью одного файла без следов на диске”.

В моём бандлере используется подход <вставить, какой именно ты выбрал>: он оказался наиболее предсказуемым для PowerShell 5.1 и реально встречающихся проектов.

Что ещё важно учесть
Циклические зависимости

Особенно болезненны при классах и using module. В отличие от JS, PowerShell не даёт удобных механизмов “частичного экспорта” на уровне типов, поэтому циклы обычно приходится разрывать архитектурно: выносить общие типы/контракты в отдельный слой.

Дебаг и сообщения об ошибках

В бандле все ошибки будут показывать строку в одном файле. Поэтому полезно добавлять в генерируемый файл маркеры:

# --- BEGIN: Modules\Auth\Auth.psm1 ---
...
# --- END: Modules\Auth\Auth.psm1 ---


Это сильно упрощает чтение stack trace.

Итог

Если вам нужен однофайловый артефакт, но вы хотите сохранить модульность разработки, то правильная модель — это не “склеить файлы”, а эмулировать поведение механизмов импорта внутри одного файла: где-то через inline-вставки, где-то через скрипт-блоки, а где-то через New-Module и управление экспортом. Самая сложная часть — using module и классы: здесь почти всегда приходится выбирать стратегию и принимать компромиссы.

Что вставить на места <...>

Чтобы раздел выглядел завершённым, тебе нужно добавить всего две вещи:

ссылка на бандлер (желательно GitHub + коротко “как использовать” одной строкой)

какую стратегию для using module ты выбрал и почему (1–2 абзаца)

Если хочешь, я могу:

адаптировать этот текст под твой тон (чуть более разговорный/ироничный как в заголовке),

или сделать “короткую” версию (примерно в 2 раза меньше), сохранив все ключевые идеи.

















**Как реализовать в бандлере**: все типы (классы и перечисления) необходимо вынести из модулей в корень бандла, и поместить их сразу после директив, которые обязательно должны быть вверху скрипта, но до определения функций. Если в модулях помимо типов есть еще и функции, то действуем по аналогии с подходом, упомянутым в разделе про `Import-Module`. А именно, помещаем содержимое модуля в скрип-блок, и с помощью `New-Module` создаем динамический модуль из этого скрипт-блока (`New=Module -ScriptBlock { ...скрипт модуля...}`).








