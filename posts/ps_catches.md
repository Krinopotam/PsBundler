# Неочевидные ловушки Powershell для тех, кто привык к классическим языкакм программирования #

PowerShell часто выглядит как обычный и достаточно развитый язык программирования: функции, объекты, типы, классы и даже GUI — всё на месте. Кажется, что если ты работал с C#, Java, JS или любым другим более «классическим» языком, то без проблем сможешь использовать и Powershell. Чаще всего это так и есть. Но стоит только начать реализовывать что-то более-менее сложное, Powershell начинает проявлять свой характер.

Причина в том, что PowerShell создавался прежде всего как интерактивный шелл, а уже потом как язык. Поэтому в нём заложено много поведения, которое удобно администраторам, работающим в конвейерах, но совершенно сбивает с толку разработчиков.

Без знания особенностей этого поведения начинающего разработчика на Powershell ждет "веселое" времяпровождение за дебаггингом кода. Прочувствовав на себе все эти "грабли" и получив дополнительно несколько седых волос, хотел бы поделиться своим опытом, возможно это кому то будет полезно.

```
Всё изложенное ниже основано на моём личном опыте и не претендует на абсолютную истину. Описанные трудности могут быть следствием моей собственной некомпетентности в PowerShell. Материал ориентирован на разработчиков, привыкших к более классическим языкам программирования
```

Начну со своего "любимого" поведения в Powershell.

## В Powershell оператор `return` не то, чем кажется ##

Сможете определить, какой результат будет выведен при запуске следующего кода?

```powershell
 function Test-Func {
     $table = New-Object System.Data.DataTable
     $table.Columns.Add("Name")

     return $false
 }

 $result = Test-Func
 if ($result) {Write-Host "Result is True"}
 else {Write-Host "Result is False"}
```

Человеку, не знакомому с особенностями Powershell, все предельно очевидно:  функция `Test-Func` в явном виде всегда возвращает `$false`, а значит результат будет `Result is False`.

Представьте мое удивление, когда я, столкнувшись с аналогичным кодом, получил `Result is True`.

А дело вот в чем. Как я уже сказал, Powershell прежде всего шелл, и только потом язык программирования. И в нашем случае работают 2 фактора:

1. Если результат вызываемой функции (или метода) не присвоен переменной, то этот результат выводится в консоль (output stream)
2. Функция возвращает не только то, что указано в `return`, но и все, что было выведено в output stream во время выполнения этой функции.

В нашей функции `Test-Func` вызывается метод `$table.Columns.Add("Name")`, который добавляет в `DataTable` новый столбец, а также возвращает экземпляр этого столбца. Так как возвращаемый результат не присвоен переменной, он попадает в output stream. Таким образом наша функция `Test-Func` возвращает массив, состоящий из двух элементов `@(Column, $false)`, а не ожидаемый нами `$false`.

Чтобы исправить нашу функцию, придется подавить вывод результата вызова метода `$table.Columns.Add("Name")`, например так:

```powershell
$null = $table.Columns.Add("Name")
```

или так

```powershell
[void]$table.Columns.Add("Name")
```

или можно так

```powershell
$table.Columns.Add("Name")| Out-Null
```

---

## Powershell разворачиваеи массивы, состоящие из 1 элемента ##

Вот небольшой пример кода

```powershell
    function Get-Many {
        $array = @("A", "B", "C")
        return $array
    }

    function Get-Single {
        $array = @("A")
        return $array
    }

    $many = Get-Many
    $single = Get-Single

    $many.GetType().Name
    $single.GetType().Name
```

Угадаете, какие типы переменных `$many` и `$single` выведет данный код?

Вроде обе функции `Get-Many` и `Get-Single` возвращают массивы, и мы можем ожидать, что результат будет одинаковым для обеих переменных:

```powershell
Object[]
Object[]
```

но на самом деле результат будет:

```powershell
Object[]
String
```

Здорово правда? Не спросив нас PowserShell "упростил" нам жизнь. А ведь мы скорее всего захотим передать массив в цикл и конечно же получим ошибку, если вместо ожидаемого массива получим `String`.

Почему так получилось? Потому что PowerShell — язык, построенный вокруг ковейеров (pipeline) и в него заложена логика удобной работы с конвейерами и выводом данных, чтобы админы могли быстро "набросать" скрипт.

Но как же быть нам, людям которые привыкли, что результатом функции должно быть именно то, что она возвращает, без всякой магии? Одно из решений - использовать общеизвестный костыль в виде запятой `,`, которая по сути оборачивает любое значение в массив.

Если мы перепишем наш код следующим образом, то все будет работатать, как мы того и ожидаем.

```powershell
    function Get-Many {
        $array = @("A", "B", "C")
        return , $array
    }

    function Get-Single {
        $array = @("A")
        return , $array
    }

    $many = Get-Many
    $single = Get-Single

    $many.GetType().Name
    $single.GetType().Name
```

Обраьтите внимание, на запятую в строке `return , $array`, именно в ней вся магия. Теперь результат будет, как мы и ожидаем:

```powershell
Object[]
Object[]
```

---

## Powershell неявно устанавливает и определяет область видимости (Scope) переменной ##

Рассмотрим следюущий пример:

```powershell
    $array = @("A", "B", "C")
    Write-Host "Old items count: $($array.Count)"

    function Add-Item {
        param($item)
        
        if ($array) {
            Write-Host "Add item"
            $array += $item
        }
    }

    Add-Item "New Item"
    Write-Host "New items count: $($array.Count)"
```

Что мы тут ожидаем увидеть?

Функция `Add-Item` должна добавить новый элемент в массив, который хранится во внешней переменной, но только если эта переменная существует и не пустая (то есть функция видит эту переменную).

на первый взгляд все ОК, но результат будет вот таким:

```powershell
Old items count: 3
Add item
New items count: 3
```

Как мы видим, количество элементов не изменилось, хотя условие проверки видимости переменной `$array` сработало, то есть функция переменную `$array` видит.

Почему так получилось? Здесь свою роль играет область видимости переменной `$array`. Как вы, скорее всего знете, в PowserShell у переменных бывают разные области видимости:

- global - переменная видна во всей сессии PowserShell
- script - переменная видна во всем скрипте
- local - локальная переменная.

Присвоение значения переменной, если такой переменной еще нет, это всегда создание новой переменной. При этом важно, что переменная, созданная в корне скрипта (в корневом скрипт-блоке), всегда имеет область видимости `script`, даже если этого не указано явно. Это работает даже для параметров корневного скрипт-блока, созданных через `param($myVar)`.

Когда функция обращается к переменной, то сначала PowserShell ищет среди локальных переменных функции. Если локальная не найдена, то поиск ведется среди переменных уровня `script`, а за тем уровня `global`.

В нашем случае, когда в функции `Add-Item` вычисляется условие `if ($array) {...}`, то в функции нет локальной переменной `$array` и PowserShell найдет переменную с таким же именем уровня `script`. То есть, обращение к переменной по имени `$array` вернет переменную `$script:array`.

А вот дальше, пытясь добавить новый элемент в массив `$array` через `+=` мы сталкиваемся со следующим: массивы в PowserShell иммутабельны, поэтому добавление элемента массива через `+=` это не что иное, как создание нового масива но уже с новым элементом и присвоение его переменной `$array`. Тем самым мы создаем новую переменную с таким же именем, но уже с областью видимости `local`  функции `Add-Item`. Значение переменной `$script:array` остается без изменений.

Для того, чтобы не попадать в подобные ситуации (да и в целом это правило хорошего тона), никогда нельзя использовать неинициализированные переменные, а при обращении к переменным уровня `script` или `global` необходиямо явно указывать их scope.

Ниже исправленный пример:

```powershell
    $array = @("A", "B", "C")
    Write-Host "Old items count: $($array.Count)"

    function Add-Item {
        param($item)
        
        if ($script:array) {
            Write-Host "Add item"
            $script:array += $item
        }
    }

    Add-Item "New Item"
    Write-Host "New items count: $($array.Count)"
```

---

## В PowerShell парсинг команд имеет приоритет над парсингом выражений ##

Простой пример:

```powershell
    Write-Host "A" + "B"
```

Мне, как человеку, больше привыкшему к другим ЯП, было очевидно, что: `Write-Host` это функция, которая должна вывести конкатенацию двух строк `A` и `B`. То есть результат я ожидал `AB`.

И конечно же я ошибся, результат будет: `A + B`

Дело в том,что Powershell имеет 2 режима парсинга:

- Command Mode: режим команд, где всё разбирается как аргументы командлета.
- Expression: режим выражений, обычный режим языка (операторы, выражения, `+`, `-`, `*`, скобки, строки)

И `Write-Host` это не просто функция, это команда. Если строка начинается с команды — строка парсится как команда, а не как выражение. И тогда `"A" + "B"` рассматривается парсером не как выражение, а как параметры команды.

Более наглядным будет отображение Abstract Syntax Tree (AST), которое формируется парсером из нашего кода.
![Ast дерево](CommandModeRulesExampleAst.PNG)

Здесь мы видим, что создается нода  `CommandAst`, имеющая 4 строковые константы `StringConstantExpressionAst`. Первая это название самой функции `Write-Host`, а вот остальные это как раз и есть то, что парсер принял за параметры функции: `A`, `+` и `B`. И хотя `+` указан без кавычек, парсер все равно посчитал его строкой (типа `BareWord`), а не выражением.

Чтобы парсер посчитал `"A" + "B"` выражением, необходимо использовать скобки.

```powershell
    Write-Host ("A" + "B")
```

Тогда результат будет ожидаемым `AB`.

---

## Медленная конкатенация строк и массивов ##

## Замыкания и области видимости ##

## Облась видимости по названию функции ##

## Магическая переменная $form ##

## Создание переменной в методе класса, в котором уже есть такое свойство ##
