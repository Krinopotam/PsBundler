Импортировать файлы можно 3 способами:
1. Dot-нотация (. "$PSScriptRoot/file.ps1"), где $PSScriptRoot путь к текущему файлу, из которого вызван импорт.
Dot-нотация означает вставку кода как есть в место вызова с той же областью видимости, что и вызывающего скрипта

2. Ampersand-нотация (& "$PSScriptRoot/file.ps1") - означает вставку кода в изолированном scope (в своем ScriptBlock)

3. Через "Import-module". Выполняется на этапе исполнения скрипта, по этому может быть в любом месте кода. 

4. Через директиву "using module". В отличее от "Import-module" директива "using module" вызывается на этапе компиляии, а не выполнения.
Относительные пути в данной директиве рассчитываются от текущего вызывающего скрипта. То есть "using module .\file1" и "$PSScriptRoot/file.ps1" с точки зрения пути одинаковы.
Важно, что хотя "using module" в вызывающем скрипте выполняется на этапе компиляции, она выполняет вызываемый скрипт, по этому в вызываемом скрипте 
команда "Export-ModuleMember" будет работать.
Если используются классы, и необходимо указывать тип класса (например [MyClass]::new вместо New-Object MyClass), то использование using module безальтернативно, так как
проверка типа класса ([MyClass]) осуществляентся на этапе компиляции. Циклические ссылки классов друг на друга запрещены. Не получится в Class A использовать тип Class B,
а в Class B использовать тип Class A. Как обходной вариант, в Class B использовать Class A с указаним дженерик типа, например [object] и для инстанцирования
класса использовать New-Object A, а не [A]::new(), импортировав сам код класса через "Import-module", а не "using module"

По умолчанию, при использовании импорте модуля чкерез Import-module или директиву "using module", если в модуле не указано, 
что экспортируется (через функцию "Export-ModuleMember" или через свойства манифеста psd1:  FunctionsToExport, CmdletsToExport, VariablesToExport, AliasesToExport),
то экспортируются все функции, CMDlet-ты и алиасы, но не экспортируются переменные.

Отсюда подходы по созданию бандла следующие:
1. В самом верху файла собираются "using namespace" со всех модулей
2. Если в корне Entry модуля есть [CmdletBinding()]param, то его также переносить в начало скрипта после директив using
3. Если в модулях есть классы, все классы выносятся в корень бандла (после [CmdletBinding()]param) и очищаются в самом модуле. Проверяем, осталось ли что то в модуле, 
   если класс вынесли (могла остатся команда "Export-module" или функции)
4. В корне бандла создаем уникальную переменную hashtable $script:__Modules[], в которой накапливаем очищенное от директив и классов  содержимое модулей, обернутое в ScriptBlock
5. Импорты обрабатываются по их типу.
- a. Dot-импорты: Заменяем на Invoke-Expression $script:__Modules[$moduleFullPath]
- a. And-импорты: Заменяем на ($script:__Modules[$moduleFullPath]).Invoke()
- c. Импорты модулей через "Import-module" - заменяем путь на (New-Module -ScriptBlock $script:__Modules[$moduleFullPath]) и устанавливаем параметр -DisableNameChecking
- d. Импорты модулей через "using module" заменяем аналогично "Import-module"

Важные нюансы:
1. Директивы "using module" и "using namespaces" должны быть обязательно в самом начале файла скрипта. Если в этом же файле скрипта есть динамические модули, 
созданные через New-Module, размещение этих директив все равно должно быть в начале файла, а не в теле динамического модуля. 
Директива "using namespace", размещенная в начале скрипта распространяет свое действие на все скрипт-блоки внутри этого файла, в том числе и на динамические модули.

2. Корневая директива [CmdletBinding()]param должна быть в самом начале файла после using, но в отличие от using, допускается ее размещение и в начале ScriptBlock модуля в бандле

3. "Set-StrictMode -Version Latest" начинает дейсвовать с момента ее выполнения. Рекумендуется ее поместить также вверх бандла, после всех вышеуказанных директив.

Ограничения:
Поиск путей импортируемых файлов в "import-Module" может быть осуществлен только если путь указан явно строковым литералом или массивом литералов (допустимо $PSScriptRoot):
    Import-Module -Name C:\Module1.psm1
    Import-Module -FullyQualifiedName C:\module1.psm1
    Import-Module C:\module1.psm1
    Import-Module $PSScriptRoot\module1.psm1, C:\module2.psm2
