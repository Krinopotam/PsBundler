# Импорты модулей в PowerShell: когда хочется как в JavaScript #

Для начала, предлагаю рассмотреть, а какие вообще в PowerShell есть варианты разбиения кода на файлы. 

Сразу оговорюсь:
>**Все дальнейшие подключения файлов буду называть импортом, а отдельные файлы - модулями, хотя в контексте PowerShell это не всегда так.**

## Методы импорта скриптов ##

Мне известно 4 основных способа:

1. `Dot`-нотация, например:`. ".\module1.psm1"`
2. `Ampersand` - нотация, например: `& ".\module1.psm1"`
3. Команда `Import-Module`, например: `Import-Module ".\module1.psm1"`
4. Директива `using module`, например: `using module ".\module1.psm1"`)

*Для вложенных импортов модулей можно еще использовать параметр `RequiredModules` в манифесте модуля (`.psd1`), но данный способ не самостоятелен и не совсем подходит под тему статьи, по этому в обзор его включать не буду.*

Рассмотрим каждый из вариантов.

### 1. `Dot`-нотация ###

Как следует из названия, синтаксис импорта начинается с точки `"."`, и дальше указывается путь до `ps1` или `psm1` импортируемого файла.

Пример использования:

```powershell
#module.ps1

Start-ModuleFunction {...}
```

```powershell
#main.ps1

. ".\module.ps1"

Start-ModuleFunction
```

При таком импорте во время выполнении скрипта PowerShell по сути просто заменит строку `. ".\module.ps1"` на содержимое файла `module`. Другими словами, все содержимое `module1` попадет в область видимости `main`. А если `module` тоже что-то импортирует через `Dot`-нотацию, например `module2`, то тогда в область видимости `main` попадет содержимое и `module2`.

Для небольших приложений данный метод может подойти, но в более сложных приложениях отсутствие изоляции областей видимости может привести к тому, что функции с одинаковыми именами могут переписать друг друга и поэтому придется обеспечивать уникальность наименований функций и переменных во всех модулях.

Важно отметить, что определение относительных путей, указанных в `Dot`-нотации, рассчитывается из текущего рабочего каталога (current location) сессии PowerShell, что не всегда удобно. Поэтому, общепринятой практикой является использование в качестве префикса пути встроенной переменной `$PSScriptRoot`, в которой хранится путь до директории, в которой расположен текущий выполняемый скрипт. Например `. "$PSScriptRoot\module.ps1"` импортирует файл из той же директории, что и вызывающий скрипт.

**Плюсы**: простота импорта  
**Минусы**: общая область видимости, отсутствие изоляции кода

### 2. `Ampersand`-нотация ###

По сути очень похоже `Dot`-нотацию.

```powershell
#main.ps1

& ".\module.ps1"

# other code...
```

Отличие от `Dot`-нотации в том, что при `Ampersand`-нотации PowerShell не только заменит `& ".\module.ps1"` на содержимое файла `module`, но и обернет его в скрипт-блок (`{...module content...}`). Это приведет к тому, что области видимости у кода из `module` и кода в `main` будут разными. Так как, области видимости в PowerShell иерархические, то есть дочерний скрипт-блок видит объекты своего родителя, но родитель не видит объекты своего дочернего скрипт-блока, то и при `Ampersand` импорте скрипт из `module` будет видеть функции из корневого скрипта `main`, но не наоборот — из скрипта `main` нельзя будет напрямую обратиться к объектам скрипта `module`. Таким образом, с одной стороны обеспечивается частичная (однонаправленная) изоляция, с другой — неудобный доступ к членам импортированного скрипта, что не очень хорошо подходит для задачи разделения кода на модули. Тем не менее, для частных задач такой подход тоже может быть применим.

**Плюсы**: простота импорта, разные области видимости  
**Минусы**: нет полной изоляции модуля, неудобно обращаться к импортированным объектам

### 3. Команда `Import-Module` ###

Основной рекомендуемый способ импорта модулей. Практически честные модули с изоляцией областей видимости. Например:

```powershell
#module.psm1

Start-PublicFunction {...}
```

```powershell
#main.ps1

Import-Module ".\module.psm1"

Start-PublicFunction
```

В данном примере все функции из `module` будут доступны в `main.ps1`, но области видимости на самом деле у них будут разными. Функции модуля будут выполнятся в контексте выполнения модуля:

- функции модуля **видят** другие функции и переменные модуля, даже если они не экспортированы.
- функции модуля **не видят** функции и переменные, определенные вне модуля (например, в `main`), даже уровня `script` (но видят `global`).

Чтобы указать, что именно должно быть экспортировано из модуля, можно (и желательно) использовать команду `Export-ModuleMember`. Например:

```powershell
#module.psm1

Start-PublicFunction {...}

Start-PrivateFunction {...}

Export-ModuleMember -Function Start-PublicFunction
```

В данном случае, экспортирована будет только функция `Start-PublicFunction`. Импортирующий скрипт будет видеть эту функцию, но не будет видеть функцию `Start-PrivateFunction`. При этом сама `Start-PublicFunction` будет видеть функцию `Start-PrivateFunction`.

По умолчанию, если команда `Export-ModuleMember` в модуле не указана, то экспортируются все функции, но не экспортируются переменные и псевдонимы (алиасы).

Также, в самой команде `Import-Module` можно указать, что импортировать, например:

```powershell
#main.ps1

Import-Module ".\module.psm1" -Function Start-PublicFunction
```

Ну а дальше, немного нюансов.

Первый нюанс заключается в том, как работает вложенный импорт (когда модуль импортирует другой модуль).

Microsoft рекомендует для вложенного импорта вместо использования `Import-Module` указывать требуемые модули через параметр`RequiredModules` в манифесте модуля (`.psd1`). Одна из причин заключается в том, что если, например, для `module1` не указать, что именно он должен экспортировать (через команду `Export-ModuleMember`), и он в свою очередь сам импортирует другой модуль `module2`, то при импорте `module1` все его функции, а также все функции `module2` каскадно попадут в область видимости вызывающего скрипта. А вот импорт через манифест таких проблем не имеет (хотя по мне это и не удобно). Поэтому рекомендуется в модуле всегда указывать, какие именно объекты должны экспортироваться.

Второй нюанс заключается в том, как ведет себя PowerShell при импорте двух функций с одинаковыми названиями. Предположим, у нас есть 2 модуля `module1.psm1` и `module2.psm1`, в которых есть функции `Use-Test`:

```powershell
#module1.psm1

function Use-Test {
    Write-Host "I am Use-Test from module1"
}

#module2.psm1
function Use-Test {
    Write-Host "I am Use-Test from module2"
}

```

Если мы последовательно импортируем оба этих модуля и вызовем функцию `Use-Test`, то сработает функция из второго модуля, который был импортирован последним.

```powershell
#main.ps1

Import-Module "$PSScriptRoot\module1.psm1"
Import-Module "$PSScriptRoot\module2.psm1"

Use-Test
```

```output
I am Use-Test from module2
```

Получается, что функция из модуля 2 "перезатерла" одноименную функции из модуля 1.

Но это не совсем так. Если мы выполним команду `Get-Command Use-Test -All`, то мы увидим, что в нашей сессии на самом деле 2 версии функции `Use-Test`, одна из `module1`, вторая из `module2`.

```output
>Get-Command Use-test -All

CommandType     Name           Version    Source
-----------     ----           -------    ------
Function        Use-Test       0.0        module2
Function        Use-Test       0.0        module1
```

И к каждой из версий мы можем обратиться по квалифицированному имени, указав имя модуля:

```powershell
module1\Use-Test
module2\Use-Test
```

```output
Use-Test from module1.psm1
Use-Test from module2.psm1
```

И этом может нас натолкнуть на мысль: а ведь неплохо было бы иметь возможность делать полностью изолированные импорты, то есть импортировать модули так, чтобы объекты из модулей не попадали напрямую в области видимости вызывающего скрипта, а чтобы обращаться к ним можно было бы только через квалифицированное имя. И такое решение на самом деле есть:

```powershell
#main.ps1

& {Import-Module "$PSScriptRoot\module1.psm1"}
& {Import-Module "$PSScriptRoot\module2.psm1"}

module1\Use-Test # вызов функции из module1
module2\Use-Test # вызов функции из module1
Use-Test         # ошибка
```

Как это работает? По умолчанию `Import-Module` помещает все экспортированные функции модуля в область видимости вызывающего скрипта. Мы избавляемся от этого поведения, вызывая импорт внутри временного скрипт-блока (`{...}`). Таким образом, все экспортированные функции попадают в область видимости временного скрипт-блока, а область видимости вызывающего скрипта не засоряется. При данном подходе мы получаем полную изоляцию областей видимости и нам не нужно заботиться об уникальности наименований функций ни в модулях, ни в вызывающем скрипте. Но есть и минус, но он касается только тех, кому нужна сборка проекта в однофайловый бандл (подробнее в разделе про бандлер).

**Плюсы**: изоляция областей видимости, гибкость, честная модульность "из коробки".  
**Минусы**: немного сложнее, чем `Dot`-нотация, чуть больше кода.

### 4. Директива `using module` ###

Согласно документации, данная директива предназначена только для импорта типов (классов, перечислений). Но, по крайней мере в PowerShell 5.1, она фактически импортирует и обычные функции с переменными по аналогии с командой `Import-Module`.

Главное отличие от `Import-Module` заключается в том, что `using module` это директива, а не команда и выполняется она на этапе парсинга скрипта, а не исполнения. Отсюда следуют другие важные нюансы:

- Директива `using` должна быть в самом начале скрипта (выше всего, что не является комментарием).
- Несмотря на то, что директива обрабатывается на этапе парсинга вызывающего скрипта, она приводит к загрузке, парсингу и выполнению импортируемого скрипта. Это позволяет в импортируемом скрипте использовать команды, например `Export-ModuleMember`, которые работают на этапе выполнения, а не парсинга. Другими словами, вызывающий скрипт будет находиться еще в режиме парсинга, а вызываемый уже в режиме исполнения.
- В момент парсинга служебные переменные, типа `$PSScriptRoot` еще не созданы и их нельзя использовать для определения пути импортируемого модуля.
- В отличие от команды `Import-Module`, в которой относительный путь рассчитывается от текущего рабочего каталога сессии PowerShell, путь в директиве `using module` рассчитывается от директории, в которой располагается вызывающий скрипт. Другими словами, если в случае с `Import-Module` для получения директории текущего файла нам приходится использовать переменную `$PSScriptRoot`, например, `$PSScriptRoot\module1.psm1`, то в случае с `using module` аналогичный результат достигается сразу через `.\module1.psm1`.

Стоит упомянуть важный нюанс, связанный с классами. Проверка типов  осуществляется на этапе компиляции, а это значит, что корректно использовать тип класса (например `[MyClass]::New()`) можно только в том случае, если он уже импортирован на этапе компиляции. Следовательно, корректный импорт классов возможен только с помощью директивы `using module`, а `Import-Module` в данном случае не подходит.

**Плюсы**: простота импорта, высокая (но не полная) изоляция, безальтернативность при импорте типов (классов и перечислений).  
**Минусы**: меньше гибкости, чем `Import-Module`, директива должна быть размещена только вначале скрипта, негативные эффекты, связанные с тем, что импорт осуществляется на этапе компиляции (разбора), а не выполнения










И вот если мы в классе хотим использовать какую-нибудь сборку, например `System.Windows.Forms`, добавляемую через `Add-Type -AssemblyName`, то можем столкнуться с проблемой. `Add-Type` это команда, выполняемая на этапе выполнения кода, а как уже было сказано выше, проверка типов ведется на этапе компиляции.  Плюс мы не можем поместить `Add-Type` в коде выше, чем  `using module`. А значит, класс не будет видеть тип `System.Windows.Forms` (мы не сможем его использовать, например для создания экземпляра `[System.Windows.Forms.Form::New()`).

Какие есть решения:

- создавать объекты через `New-Object System.Windows.Forms.Form`, но при этом мы теряем строгую типизацию, автодополнение в IDE, а также немного производительность.
- если необходимо используем только статические сборки, то вместо `Add-Type` лучше использовать директиву `using assembly`, например `using assembly System.Windows.Forms`. Она также выполняется на этапе компиляции.
- если же необходимо использовать динамические сборки на основе встраиваемого C# кода, то можно создать отдельный модуль с необходимыми сборками, а уже этот модуль импортировать через `using module`. Например:

```powershell
#typesModule.psm1

Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName System.Drawing

Add-Type @"
using System;
using System.Runtime.InteropServices;
public class Win32 {
    [DllImport("user32.dll", CharSet = CharSet.Auto)]
    public static extern IntPtr SendMessage(IntPtr hWnd, int msg, int wParam, IntPtr lParam);
}
"@

#root.ps1
using module ./typesModule.psm1

Class MyClass {
    [void]CreateForm () {
        $form = [System.Windows.Forms.Form]::New() # используем статическую сборку
        [void][Win32]::SendMessage(...) # используем динамическую сборку
    }
}

```

В этом случае загрузка сборок `Forms` и `Drawing` и класса `Win32` будет выполнена до компиляции `root.ps1` и их можно будет использовать напрямую.

Но есть и минус — мне не известно надежное и простое решение, как корректно реализовать такое поведение в бандле, следовательно, такой подход будет не совместим с нашим бандлером. Если использование бандлера не предполагается, то решение вполне рабочее.

**Как реализовать в бандлере**: все типы (классы и перечисления) необходимо вынести из модулей в корень бандла, и поместить их сразу после директив, которые обязательно должны быть вверху скрипта, но до определения функций. Если в модулях помимо типов есть еще и функции, то действуем по аналогии с подходом, упомянутым в разделе про `Import-Module`. А именно, помещаем содержимое модуля в скрип-блок, и с помощью `New-Module` создаем динамический модуль из этого скрипт-блока (`New=Module -ScriptBlock { ...скрипт модуля...}`).








