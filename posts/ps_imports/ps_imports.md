# Импорты модулей в PowerShell: когда хочется как в JavaScript #

Для начала, предлагаю рассмотреть, а какие вообще в PowerShell есть варианты разбиения кода и импорта на модулей.

Мне известно 4 основных способа:

1. `Dot`-нотация 
2. `Ampersand` - нотация, например: `& ".\module1.psm1"`
3. Команда `Import-Module`, например: `Import-Module ".\module1.psm1"`
4. Директива `using module`, например: `using module ".\module1.psm1"`)


Рассмотрим каждый из вариантов.

## 1. `Dot`-нотация ##

Пример использования:

```powershell
. ".\module1.psm1"

Start-ModuleFunction
```

Как понятно из названия, импорт начинается с точки `"."`, и дальше указывается путь до `ps1` или `psm1` импортируемого файла.

При таком импорте PowerShell в процессе выполнения скрипта по сути вставляет код из импортируемого файла прямо в то место, где указана `dot`-нотация. Важно, что область видимости у импортируемого и вызывающего скрипта будет общая. То есть, в нашем примере, функции и переменные из `module1.psm1` будут добавлены в область видимости корневого скрипта.

Для небольших приложений данный метод может подойти, но в более сложных приложениях отсутствие изоляции областей видимости может привести к тому, что функции с одинаковыми именами могут переписать друг друга и поэтому придется обеспечивать уникальность наименований функций и переменных во всех модулях.

**Как реализовать в бандлере**: тут все просто, по большому счету достаточно просто склеить ("смержить") все модули в один файл.

**Плюсы**: простота импорта

**Минусы**: общая область видимости, отсутствие изоляции кода

## 2. `Ampersand`-нотация ##

По сути очень напоминает `dot`-нотацию.

```powershell
& ".\module1.psm1"

# My code...
```

Важное отличие в том, что при импорте PowerShell по сути обернет модуль в скрипт-блок, а следовательно области видимости у скрипта из модуля и вызывающего скрипта будут разными. Так как, области видимости в PowerShell иерархические, то есть дочерний скрипт-блок видит объекты своего родителя, но родитель не видит объекты своего дочернего скрипт-блока, то и при `ampersand` импорте скрипт из модуля будет видеть функции из корневого скрипта, но корневой скрипт не будет видеть функции из импортированного модуля. Таким образом, с одной стороны обеспечивается частичная (однонаправленная) изоляция, с другой — неудобный доступ к членам импортированного скрипта, что не очень хорошо подходит для задачи разделения кода на модули. Тем не менее, для частных задач такой подход тоже может быть применим.

**Как реализовать в бандлере**: тоже все просто, склеиваем все модули в один файл, но при этом содержимое каждого модуля оборачиваем в фигурные скобки (скрипт-блок): `{ ...код модуля...  }`

**Плюсы**: простота импорта, разные области видимости

**Минусы**: нет полной изоляции модуля, неудобно обращаться к импортированным объектам

## 4. Директива `using module` ##

Согласно документации, данная директива предназначена только для импорта типов (классов, перечислений). Но, по крайней мере в PowerShell 5.1, она фактически импортирует и обычные функции с переменными по аналогии с командой `Import-Module`.

Главное отличие от `Import-Module` заключается в том, что `using module` это директива, а не команда и выполняется она на этапе компиляции (разбора) скрипта (compile-time), а не исполнения (run-time). Отсюда следуют другие важные нюансы:

- Директива `using module` должна быть в самом начале скрипта (выше всего, что не является комментарием).
- Несмотря на то, что директива обрабатывается на этапе компиляции вызывающего скрипта, она приводит к загрузке и выполнению импортируемого скрипта. Это позволяет в импортируемом скрипте использовать команды, например `Export-ModuleMember`, которые работают на этапе выполнения, а не компиляции.
- В момент компиляции служебные переменные, типа `$PSScriptRoot` еще не созданы и их нельзя использовать для определения пути импортируемого модуля.
- В отличие от команды `Import-Module`, в которой относительный путь рассчитывается от текущего рабочего каталога (current location) сессии PowerShell, путь в директиве `using module` рассчитывается от директории, в которой располагается вызывающий скрипт. Другими словами, если в случае с `Import-Module` для получения директории текущего файла нам приходится использовать переменную `$PSScriptRoot`, например, `$PSScriptRoot\module1.psm1`, то в случае с `using module` аналогичный результат достигается сразу через `.\module1.psm1`.

Стоит упомянуть важный нюанс, связанный с классами. Проверка типов  осуществляется на этапе компиляции, а это значит, что корректно использовать тип класса (например `[MyClass]::New()`) можно только в том случае, если он уже импортирован на этапе компиляции. Следовательно, корректный импорт классов возможен только с помощью директивы `using module`, а `Import-Module` в данном случае не поможет.

И вот если мы в классе хотим использовать какую-нибудь сборку, например `System.Windows.Forms`, добавляемую через `Add-Type -AssemblyName`, то можем столкнуться с проблемой. `Add-Type` это команда, выполняемая на этапе выполнения кода, а как уже было сказано выше, проверка типов ведется на этапе компиляции.  Плюс мы не можем поместить `Add-Type` в коде выше, чем  `using module`. А значит, класс не будет видеть тип `System.Windows.Forms` (мы не сможем его использовать, например для создания экземпляра `[System.Windows.Forms.Form::New()`).

Какие есть решения:

- создавать объекты через `New-Object System.Windows.Forms.Form`, но при этом мы теряем строгую типизацию, автодополнение в IDE, а также немного производительность.
- если необходимо используем только статические сборки, то вместо `Add-Type` лучше использовать директиву `using assembly`, например `using assembly System.Windows.Forms`. Она также выполняется на этапе компиляции.
- если же необходимо использовать динамические сборки на основе встраиваемого C# кода, то можно создать отдельный модуль с необходимыми сборками, а уже этот модуль импортировать через `using module`. Например:

```powershell
#typesModule.psm1

Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName System.Drawing

Add-Type @"
using System;
using System.Runtime.InteropServices;
public class Win32 {
    [DllImport("user32.dll", CharSet = CharSet.Auto)]
    public static extern IntPtr SendMessage(IntPtr hWnd, int msg, int wParam, IntPtr lParam);
}
"@

#root.ps1
using module ./typesModule.psm1

Class MyClass {
    [void]CreateForm () {
        $form = [System.Windows.Forms.Form]::New() # используем статическую сборку
        [void][Win32]::SendMessage(...) # используем динамическую сборку
    }
}

```

В этом случае загрузка сборок `Forms` и `Drawing` и класса `Win32` будет выполнена до компиляции `root.ps1` и их можно будет использовать напрямую.

Но есть и минус — мне не известно надежное и простое решение, как корректно реализовать такое поведение в бандле, следовательно, такой подход будет не совместим с нашим бандлером. Если использование бандлера не предполагается, то решение вполне рабочее.

**Как реализовать в бандлере**: все типы (классы и перечисления) необходимо вынести из модулей в корень бандла, и поместить их сразу после директив, которые обязательно должны быть вверху скрипта, но до определения функций. Если в модулях помимо типов есть еще и функции, то действуем по аналогии с подходом, упомянутым в разделе про `Import-Module`. А именно, помещаем содержимое модуля в скрип-блок, и с помощью `New-Module` создаем динамический модуль из этого скрипт-блока (`New=Module -ScriptBlock { ...скрипт модуля...}`).

**Плюсы**: простота импорта, высокая (но не полная) изоляция, безальтернативность при импорте типов (классов и перечислений).

**Минусы**: меньше гибкости, чем `import-Module`, директива должна быть размещена только вначале скрипта, негативные эффекты, связанные с тем, что импорт осуществляется на этапе компиляции (разбора), а не выполнения








Предположим, у нас есть 2 модуля `module1.psm1` и `module2.psm1`, в которых есть функции с одинаковыми названиями `Use-Test`:

```powershell
######## module1.psm1 #########
function Use-Test {
    Write-Host "I am Use-Test from module1"
}

######## module2.psm1 #########
function Use-Test {
    Write-Host "I am Use-Test from module2"
}

```

Если мы последовательно импортируем оба этих модуля и вызовем функцию `Use-Test`, то сработает функция из второго модуля, который был импортирован последним.

```powershell
Import-Module "$PSScriptRoot\module1.psm1"
Import-Module "$PSScriptRoot\module2.psm1"

Use-Test
```

```output
I am Use-Test from module2
```

Получается, что функция из модуля 2 "перезатерла" одноименную функции из модуля 1.

Но это не в полной мере так. Если мы выполним команду `Get-Command Use-Test -All`, то мы увидим, что в нашей сессии на самом деле 2 версии функции `Use-Test`, одна из `module1`, вторая из `module2`.

```output
>Get-Command Use-test -All

CommandType     Name           Version    Source
-----------     ----           -------    ------
Function        Use-Test       0.0        module2
Function        Use-Test       0.0        module1
```

И к каждой из версий мы можем обратиться по квалифицированному имени, указав имя модуля:

```powershell
module1\Use-Test
module2\Use-Test
```

```output
Use-Test from module1.psm1
Use-Test from module2.psm1
```

При этом, если `Use-Test` в обоих модулях вызывает другую одноименную функцию, например `Use-SubTest`, то PowerShell сначала попытается найти и вызвать эту функцию в соответствующем модуле, а потом и во всей области видимости сессии.